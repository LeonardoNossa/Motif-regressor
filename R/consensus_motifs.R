#' Consensus Motifs
#'
#' This function calculates the consensus motifs across a list of data frames.
#'
#' @param df_list A list of data frames.
#' @param by_regressor Logical. If \code{TRUE}, the consensus motifs are
#' calculated by condition across all data frames. If \code{FALSE}, the
#' consensus motifs are calculated for each data frame individually.
#'
#' @return A named list where each element contains the consensus motifs as a
#' named vector of percentages.
#'
#' @export
consensus_motifs <- function(df_list, by_regressor = TRUE) {
  for (object in df_list) {

    if (!is(object, "data.frame")) {
      err_msg <- paste0("Please, the provided list must contain only",
                        " dataframes, consider providing the output of",
                        " 'models2dataframe' function.")
      stop(err_msg)
    }
  }

  output <- list()
  conditions <- unique(unlist(df_list)[grepl("conditions",
                                             names(unlist(df_list)))])
  if (by_regressor) {
    for (condition in conditions) {
      all_motifs_in_condition <- lapply(X = df_list, FUN = function(df) {
        subset_df <- df$motifs[df$conditions == condition]
        return(subset_df)
      })
      all_motifs_in_condition <- unlist(all_motifs_in_condition)
      sorted_motifs_summary <- sort(table(all_motifs_in_condition),
                                    decreasing = TRUE)
      sorted_motifs_summary <- ((sorted_motifs_summary/length(df_list))*100)
      output[[condition]] <- as.vector(sorted_motifs_summary)
      names(output[[condition]]) <- names(sorted_motifs_summary)

    }
  } else {
    regressions <- names(df_list)
    for (i in seq_len(length(df_list))) {
      df_regr <- df_list[[i]]
      sorted_motifs_summary <- sort(table(df_regr$motifs), decreasing = TRUE)
      sorted_motifs_summary <- ((sorted_motifs_summary/length(conditions))*100)
      output[[regressions[i]]] <- as.vector(sorted_motifs_summary)
      names(output[[i]]) <- names(sorted_motifs_summary)
    }


  }

  return(output)
}

#' Heatmap of Consensus Motif Inclusivity
#'
#' This function creates a heatmap to visualize the inclusivity of motifs
#' across conditions or regression models based on the output of the
#' \code{consensus_motifs} function.
#'
#' @param consensus_output A named list generated by the \code{consensus_motifs}
#'  function. The names of the list represent either conditions or regression
#'  models, and the elements contain named vectors of motif inclusivity
#'  percentages.
#'
#' @return A ComplexHeatmap object representing the heatmap.
#' @importFrom ComplexHeatmap Heatmap
#' @importFrom ComplexHeatmap draw
#' @importFrom circlize colorRamp2
#' @importFrom reshape2 acast
#' @export
consensus_motifs_heatmap <- function(consensus_output) {
  if (any(c("LM", "SVM", "PLS", "Randomized_lasso") %in% names(consensus_output))) {
    x_label <- "Regressors"
    title <- "Heatmap of Motif Inclusivity Across Conditions"
  } else {
    x_label <- "Conditions"
    title <- "Heatmap of Motif Inclusivity Across Regression Models"
  }

  all_data <- lapply(names(consensus_output), function(condition) {
    data.frame(
      Condition = condition,
      Motif = names(consensus_output[[condition]]),
      Frequency = unname(consensus_output[[condition]])
    )
  })
  long_df <- do.call(rbind, all_data)

  long_df$Condition <- factor(long_df$Condition, levels = unique(long_df$Condition))
  long_df$Motif <- factor(long_df$Motif, levels = unique(long_df$Motif))

  matrix <- reshape2::acast(long_df, Motif ~ Condition, value.var = "Frequency", fill = 0)

  color_fun <- circlize::colorRamp2(c(0, 50, 100), c("white", "lightblue", "blue"))

  heatmap <- ComplexHeatmap::Heatmap(
    matrix,
    name = "Inclusivity (%)",
    col = color_fun,
    cluster_rows = FALSE,
    cluster_columns = FALSE,
    row_names_side = "left",
    row_names_gp = gpar(fontsize = 8),
    column_names_gp = gpar(fontsize = 10),
    column_names_rot = 45,
    width = unit(10, "cm"),
    height = unit(10, "cm"),
    row_title = "Motifs",
    row_title_side = "left",
    column_title = x_label,
    column_title_side = "bottom",
    heatmap_legend_param = list(
      at = c(0, 25, 50, 75, 100),
      labels = c("0%", "25%", "50%", "75%", "100%"),
      legend_gp = gpar(fontsize = 8)
    )
  )

  ComplexHeatmap::draw(
    heatmap,
    heatmap_legend_side = "right",
    annotation_legend_side = "right",
    column_title = title,
    column_title_side = "top",
    column_title_gp = gpar(fontsize = 12, fontface = "bold")
  )
}

#' Retrieve the Type of a Regression Model
#'
#' This function determines the type of a given regression model based on its
#' class.
#'
#' @param model An object representing a regression model. The model's class is
#'  used to determine its type.
#'
#' @return A character string indicating the type of regression model:
#' \itemize{
#'   \item `"svm"` for Support Vector Machine models.
#'   \item `"pls"` for Partial Least Squares regression models.
#'   \item `"lasso"` for Randomized Lasso regression models (stored as
#'   `SummarizedExperiment` objects).
#'   \item `"simple"` for simple linear regression models.
#' }
retrieve_regressor_type <- function(model) {
  if (class(model) == "svm") {
    return("svm")
  } else if (class(model) == "mvr") {
    return("pls")
  } else if (class(model) == "SummarizedExperiment") {
    return("lasso")
  } else if (class(model) == "lm") {
    return("simple")
  }
}
